<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Синхро PDF</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700;800&display=swap" rel="stylesheet">

    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://unpkg.com/html5-qrcode" type="text/javascript"></script>
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        :root {
            --color-bg: #222222;
            --color-card: #ffffff;
            --color-attention-high: #b80000;
            --color-attention-med: #0b5394;
            --color-hand: #f59e0b;
            --color-success: #2e7d32;
            --color-error: #c62828;
            --color-text: #000000;
            --color-border: #cccccc;
            --shadow: 0 4px 20px rgba(0,0,0,0.15);
            --landscape-rotation: 0deg; 
            --toolbar-size: 75px;
        }

        * { box-sizing: border-box; touch-action: manipulation; -webkit-tap-highlight-color: transparent; }

        body {
            margin: 0; padding: 0;
            background-color: var(--color-bg);
            color: var(--color-text);
            font-family: 'Montserrat', sans-serif;
            font-size: 16px;
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            height: 100dvh; width: 100%;
            overflow: hidden; 
            display: flex; flex-direction: column; 
        }

        /* --- UI OVERLAYS --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(244, 244, 244, 1); z-index: 200;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            padding: 5px;
        }
        
        .card {
            background: var(--color-card); 
            color: var(--color-text);
            padding: 0.6rem; 
            border-radius: 1.2rem;
            text-align: center; 
            width: 100%; max-width: 400px;
            height: auto;
            max-height: 100%; 
            display: flex; flex-direction: column; 
            align-items: center;
            justify-content: space-between;
            box-shadow: var(--shadow);
            border: 2px solid var(--color-border);
            gap: 5px;
        }
        
        .hidden { display: none !important; }

        h3 { margin: 0; color: var(--color-text); font-weight: 700; font-size: 1.1rem; flex-shrink: 0; }
        
        /* --- ROLE BUTTONS --- */
        #role-menu {
            display: flex; flex-direction: column; gap: 15px;
            width: 100%; max-width: 500px;
            height: 100%; padding: 10px 0;
            justify-content: center;
        }

        .role-btn {
            flex: 1; max-height: 40vh; 
            border: none; border-radius: 1.2rem;
            font-family: 'Montserrat', sans-serif;
            font-size: clamp(1.5rem, 5vw, 2.2rem); 
            font-weight: 800;
            color: white; cursor: pointer;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            gap: 15px;
            box-shadow: 0 6px 15px rgba(0,0,0,0.2);
            transition: transform 0.1s;
            text-transform: uppercase;
        }
        .role-btn:active { transform: scale(0.97); }
        .role-listener { background-color: var(--color-attention-high); border: 2px solid var(--color-attention-high); }
        .role-speaker { background-color: var(--color-attention-med); border: 2px solid var(--color-attention-med); }
        
        /* --- ACTION BAR (Bottom Buttons) --- */
        .action-bar {
            display: flex; width: 100%; gap: 10px; margin-top: 2px; flex-shrink: 0;
        }
        
        button.btn-primary {
            background: var(--color-attention-high); 
            color: white; border: none; 
            padding: 0.6rem; 
            font-size: 1.1rem; font-family: 'Montserrat', sans-serif; font-weight: 700;
            border-radius: 0.8rem; cursor: pointer; 
            flex: 2; 
            display: flex; align-items: center; justify-content: center; gap: 10px;
            box-shadow: 0 4px 10px rgba(184, 0, 0, 0.3); text-transform: uppercase;
        }
        button.btn-primary:active { transform: scale(0.98); }
        button.btn-primary:disabled { opacity: 0.5; cursor: not-allowed; box-shadow: none; }

        button.btn-secondary { 
            background: white; color: var(--color-attention-med); border: 2px solid var(--color-attention-med); 
            padding: 0.6rem; 
            font-size: 1rem; font-weight: 600;
            border-radius: 0.8rem; cursor: pointer;
            flex: 1; 
            display: flex; align-items: center; justify-content: center;
            font-family: 'Montserrat', sans-serif; 
        }
        button.btn-secondary:active { background: #f0f8ff; }

        input[type="text"] {
            padding: 0.6rem; 
            width: 100%; background: #fff; 
            border: 2px solid var(--color-attention-med); color: var(--color-attention-med); 
            border-radius: 0.8rem; outline: none;
            font-size: 1rem; text-align: left;
            font-family: 'Montserrat', sans-serif; font-weight: 600; flex-shrink: 0;
            transition: border-color 0.3s, background-color 0.3s;
        }
        input.input-success { border-color: var(--color-success) !important; background-color: #e8f5e9 !important; color: var(--color-success) !important; }
        input.input-error { border-color: var(--color-error) !important; background-color: #ffebee !important; color: var(--color-error) !important; }
        input[type="text"]::placeholder { color: #88a; font-weight: 400; font-size: 0.9rem; }

        /* --- LOCKER INTERFACE --- */
        #lock-container {
            display: flex; justify-content: center; align-items: center;
            gap: 2px; width: 100%; user-select: none;
            flex-shrink: 0; 
        }
        .lock-group { display: flex; gap: 1px; }
        .lock-spacer { width: 6px; }
        .digit-column { display: flex; flex-direction: column; align-items: center; gap: 1px; }
        .digit-btn {
            background: #f0f0f0; border: none; color: var(--color-attention-med);
            width: 32px; height: 28px; border-radius: 4px; cursor: pointer;
            display: flex; align-items: center; justify-content: center; touch-action: manipulation;
        }
        .digit-btn:active { background: #ddd; transform: scale(0.95); }
        .digit-display {
            font-size: 1.4rem; font-weight: 800; width: 32px; height: 36px;
            display: flex; align-items: center; justify-content: center;
            background: white; border: 2px solid var(--color-attention-med);
            border-radius: 4px; color: var(--color-text); z-index: 2;
        }

        /* --- QR SCANNER (FIXED ASPECT RATIO & FILL) --- */
        #reader {
            width: 85%;
            aspect-ratio: 1/1;
            margin: 5px auto;
            border-radius: 1rem; 
            overflow: hidden; 
            background: #000;
            border: 2px solid var(--color-attention-med); 
            position: relative;
            flex-shrink: 0; /* Stop it from collapsing */
        }
        
        /* Force the video to absolutely fill the square container */
        #reader video { 
            width: 100% !important; 
            height: 100% !important; 
            object-fit: cover !important; 
            border-radius: 1rem !important;
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
        }
        
        #html5-qrcode-button-camera-stop, #html5-qrcode-anchor-scan-type-change, #reader__dashboard_section_csr span { display: none !important; }
        
        #reader button {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background-color: var(--color-attention-high) !important; color: white !important;
            border: none !important; padding: 10px 20px !important; border-radius: 0.5rem !important;
            font-family: 'Montserrat', sans-serif !important; font-weight: 600 !important; white-space: nowrap; z-index: 100;
        }

        /* --- QR GENERATOR --- */
        #qr-container {
            background:white; padding:5px; display:inline-flex; 
            align-items: center; justify-content: center;
            border: 2px solid var(--color-attention-med); border-radius: 10px;
            flex-shrink: 1; flex-grow: 0;
            min-height: 0;
            max-height: 35vh; 
            aspect-ratio: 1/1;
        }
        #qr-container img { 
            max-width: 100%; max-height: 100%; 
            width: auto !important; height: auto !important; 
            object-fit: contain; 
        }

        /* --- PDF VIEWER --- */
        #pdf-container {
            flex: 1; width: 100%; min-height: 0; min-width: 0;
            position: relative; background: #222; 
            display: flex; justify-content: center; align-items: center;
            padding: 0; overflow: hidden; 
        }

        body.fullscreen-mode #toolbar { display: none !important; }
        body.fullscreen-mode #pdf-container { width: 100%; height: 100%; background: black; }
        body.fullscreen-mode #fs-controls { display: block !important; }

        .canvas-wrapper {
            position: relative; box-shadow: 0 4px 15px rgba(0,0,0,0.5); background: white;
            max-width: 100%; max-height: 100%; display: flex; 
        }
        
        canvas#the-canvas { display: block; max-width: 100%; max-height: 100%; object-fit: contain; }
        canvas#draw-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            touch-action: none; cursor: crosshair; pointer-events: none; 
        }

        /* HAND OVERLAY */
        #hand-overlay {
            position: absolute; top: 10px; left: 10px;
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid var(--color-hand); border-radius: 20px;
            padding: 8px 16px; display: flex; align-items: center; gap: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2); z-index: 50; font-weight: 700; color: #000;
        }
        
        #offline-indicator {
            position: fixed; top: 10px; left: 50%; transform: translateX(-50%);
            background: rgba(100, 100, 100, 0.9); color: white; border-radius: 20px;
            padding: 8px 16px; display: flex; align-items: center; gap: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2); z-index: 250; font-weight: 600; font-size: 0.9rem;
        }
        
        .bounce { animation: bounce 0.5s infinite alternate; }
        @keyframes bounce { from { transform: translateY(0); } to { transform: translateY(-5px); } }
        .spin { animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .touch-zone { position: fixed; top: 0; bottom: 80px; width: 15%; z-index: 10; }
        #zone-prev { left: 0; }
        #zone-next { right: 0; }

        /* Modal Base */
        .modal-overlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255,255,255,0.98); z-index: 300;
            justify-content: center; align-items: center; flex-direction: column; padding: 20px;
        }
        .modal-content { 
            background: white; padding: 1.5rem; border-radius: 1.5rem; 
            box-shadow: var(--shadow); border: 2px solid var(--color-attention-med);
            display: flex; flex-direction: column; align-items: center; text-align: center;
            max-width: 90%;
        }

        /* --- TOOLBAR --- */
        #toolbar {
            width: 100%; height: auto; min-height: var(--toolbar-size);
            flex: 0 0 auto; padding-bottom: env(safe-area-inset-bottom);
            background-color: var(--color-attention-med);
            display: flex; justify-content: center; align-items: center; gap: 2px;
            box-shadow: 0 -4px 15px rgba(0,0,0,0.2); z-index: 20; position: relative; 
        }

        @media (orientation: landscape) {
            body { flex-direction: row; }
            #toolbar {
                width: var(--toolbar-size); height: 100%; flex: 0 0 var(--toolbar-size);
                flex-direction: column; box-shadow: -4px 0 15px rgba(0,0,0,0.2);
                padding-bottom: 0; padding-right: env(safe-area-inset-right); min-height: 0;
            }
            #page-info { transform: rotate(var(--landscape-rotation)); margin: 5px 0; }
            .tool-btn { width: 100%; height: auto; min-height: 50px; }
        }

        #page-info { 
            color: white; font-size: 1rem; font-weight: 600; 
            min-width: 45px; text-align: center; white-space: nowrap; margin: 0 2px;
            transition: transform 0.3s ease; transform: rotate(var(--landscape-rotation));
        }

        .tool-btn {
            background: none; border: none; color: white; cursor: pointer; padding: 0;
            display: flex; align-items: center; justify-content: center;
            flex-shrink: 1; min-width: 44px; height: 100%; position: relative; 
        }
        .tool-btn:active .btn-inner { background-color: rgba(255,255,255,0.2); border-radius: 8px; }

        .btn-inner {
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            padding: 4px; transition: transform 0.3s ease; width: 100%; height: 100%;
            position: relative; transform: rotate(var(--landscape-rotation));
        }
        .btn-inner span { font-size: 0.65rem; margin-top: 3px; font-weight: 500; white-space: nowrap; }
        .tool-btn.danger { color: #ffcccc; } 
        
        .hand-active .btn-inner { color: var(--color-hand) !important; background: rgba(255,255,255,0.1); border-radius: 8px; }
        .hand-active i { fill: var(--color-hand); }

        .hand-timer-svg {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%) rotate(-90deg);
            width: 36px; height: 36px; pointer-events: none; display: none; z-index: 0; transition: top 0.2s; 
        }
        #fs-hand .hand-timer-svg { top: 50%; width: 60px; height: 60px; }
        .hand-active .hand-timer-svg, .fs-btn-active .hand-timer-svg { display: block; }
        #btn-hand.hand-active span { display: none; }
        #btn-hand.hand-active .hand-timer-svg { top: 50%; }

        .hand-timer-path {
            fill: none; stroke: var(--color-hand); stroke-width: 3; stroke-dasharray: 100, 100; stroke-dashoffset: 0;
        }
        .hand-active .hand-timer-path, .fs-btn-active .hand-timer-path { animation: timeCircle 10s linear forwards; }
        @keyframes timeCircle { 0% { stroke-dashoffset: 0; } 100% { stroke-dashoffset: 100; } }

        #fs-controls {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 150;
        }
        #fs-exit, #fs-hand, #fs-page-info { pointer-events: auto; transition: transform 0.3s ease; }
        #fs-exit {
            position: absolute; top: 20px; right: 20px; background: rgba(0, 0, 0, 0.6); color: white;
            border: none; border-radius: 50%; width: 44px; height: 44px;
            display: flex; align-items: center; justify-content: center; cursor: pointer;
            transform: rotate(var(--landscape-rotation));
        }
        #fs-page-info {
            position: absolute; top: 20px; left: 20px; background: rgba(0, 0, 0, 0.6); color: white;
            padding: 8px 16px; border-radius: 20px; font-weight: 700; font-size: 0.9rem;
            transform: rotate(var(--landscape-rotation)); origin: center;
        }
        #fs-hand {
            position: absolute; bottom: 30px; right: 20px; background: white; color: #aaa;
            border: 2px solid #ccc; border-radius: 50%; width: 64px; height: 64px;
            display: flex; align-items: center; justify-content: center; cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3); transform: rotate(var(--landscape-rotation));
        }
        #fs-hand:active { transform: scale(0.95); }
        .fs-btn-active { background-color: var(--color-hand) !important; color: white !important; border: none !important; }

        .id-display {
            font-size: 1.8rem; font-weight: 800; color: var(--color-attention-med);
            background: #f0f8ff; padding: 5px 10px; border-radius: 10px;
            border: 2px dashed var(--color-attention-med); letter-spacing: 2px;
            user-select: text; flex-shrink: 0;
        }
        .id-label { font-size: 0.7rem; text-transform: uppercase; color: #666; font-weight: 700; }

        /* Compact Speaker Stats */
        #speaker-stats {
            display: flex; justify-content: center; align-items: center;
            width: 100%; padding: 5px; background: #f9f9f9;
            border-radius: 0.8rem; border: 1px solid #eee; 
            flex-shrink: 0;
        }
        .stat-item { display: flex; flex-direction: column; align-items: center; }
        .stat-val { font-size: 1.4rem; font-weight: 800; color: var(--color-attention-med); line-height: 1; }
        .stat-label { font-size: 0.65rem; color: #666; font-weight: 600; text-transform: uppercase; margin-top: 2px; }

    </style>
</head>
<body>

    <!-- 1. UI LAYER -->
    <div id="ui-layer">
        
        <!-- STEP 1: ROLE SELECTION -->
        <div id="role-menu">
            <button class="role-btn role-listener" onclick="setupListener()">
                <div class="btn-inner">
                    <i data-lucide="ear" width="72" height="72"></i>
                    Я СЛУХАЧ
                </div>
            </button>
            <button class="role-btn role-speaker" onclick="setupSpeaker()">
                <div class="btn-inner">
                    <i data-lucide="mic-2" width="72" height="72"></i>
                    Я ВЕДУЧИЙ
                </div>
            </button>
        </div>

        <!-- STEP 2A: LISTENER SETUP (COMPACT) -->
        <div id="listener-menu" class="card hidden">
            <h3>Підключення</h3>
            
            <!-- SCANNER (CENTERED) -->
            <div id="reader"></div> 
            
            <div id="lock-container">
                <div class="lock-group">
                    <div class="digit-column" id="d0"></div>
                    <div class="digit-column" id="d1"></div>
                    <div class="digit-column" id="d2"></div>
                </div>
                <div class="lock-spacer"></div>
                <div class="lock-group">
                    <div class="digit-column" id="d3"></div>
                    <div class="digit-column" id="d4"></div>
                    <div class="digit-column" id="d5"></div>
                </div>
                <div class="lock-spacer"></div>
                <div class="lock-group">
                    <div class="digit-column" id="d6"></div>
                    <div class="digit-column" id="d7"></div>
                    <div class="digit-column" id="d8"></div>
                </div>
            </div>

            <!-- Action Bar: Back and Join -->
            <div class="action-bar">
                <button class="btn-secondary" onclick="location.reload()">
                    <i data-lucide="arrow-left" width="24" height="24"></i>
                </button>
                <button class="btn-primary" onclick="joinGame()">
                    <i data-lucide="arrow-right" width="28" height="28"></i>
                </button>
            </div>
        </div>

        <!-- STEP 2B: SPEAKER SETUP (COMPACT) -->
        <div id="speaker-menu" class="card hidden">
            <h3>Кабінет Ведучого</h3>
            
            <div id="qr-container"></div>
            
            <div style="display:flex; flex-direction:column; align-items: center; gap:2px; width:100%;">
                <span class="id-label">Код доступу</span>
                <div id="meeting-id-display" class="id-display">...</div>
            </div>

            <div id="speaker-stats">
                <div class="stat-item">
                    <div class="stat-val" id="speaker-user-count">0</div>
                    <div class="stat-label">Підключено</div>
                </div>
            </div>

            <div style="width: 100%; display: flex; flex-direction: column; gap: 5px;">
                <input type="text" id="gdrive-input" oninput="resetInputColor()" placeholder="URL презентації (PDF)">
            </div>
            
            <div id="sync-status" style="display:none; color: var(--color-attention-high); font-weight:700; font-size: 1rem;">
                <i data-lucide="loader-2" class="spin"></i> Завантаження...
            </div>

            <!-- Action Bar: Back and Start -->
            <div class="action-bar">
                <button class="btn-secondary" onclick="location.reload()">
                    <i data-lucide="arrow-left" width="24" height="24"></i>
                </button>
                <button id="btn-start-sync" onclick="startDistribution()" class="btn-primary" disabled>
                    <i data-lucide="play" width="28" height="28"></i>
                </button>
            </div>
        </div>

        <!-- LOADING SCREEN -->
        <div id="loading-menu" class="card hidden" style="justify-content: center; border-color: var(--color-attention-med);">
            <i data-lucide="loader-2" class="spin" style="animation: spin 1s linear infinite; color: var(--color-attention-med); width:64px; height:64px;"></i>
            <h3 id="loading-msg" style="margin-top: 20px;">З'єднання...</h3>
            <button class="btn-secondary" onclick="forceReload()" style="margin-top: 20px; border-color: #ccc; color: #666; width: auto;">
                <i data-lucide="refresh-cw"></i> ОНОВИТИ
            </button>
        </div>
    </div>

    <!-- 2. MAIN VIEWER -->
    
    <div id="offline-indicator" class="hidden">
        <i data-lucide="wifi-off" width="20" height="20"></i>
        <span>Offline Mode</span>
    </div>

    <div id="qr-modal" class="modal-overlay" onclick="toggleQR()">
        <div id="qr-code-box" class="modal-content" onclick="event.stopPropagation()">
            <h3 style="margin-bottom: 15px;">Поділитися (Сторінка <span id="qr-page-num">1</span>)</h3>
            <div id="qrcode-modal-tgt"></div>
            <div id="qr-modal-id" class="id-display" style="font-size:1.5rem; margin-top:15px;"></div>
            <button class="btn-secondary" style="margin-top:20px;" onclick="toggleQR()">ЗАКРИТИ</button>
        </div>
    </div>

    <div id="notification-modal" class="modal-overlay" onclick="closeNotification()">
        <div class="modal-content" onclick="event.stopPropagation()" style="border-color: var(--color-attention-high);">
            <i data-lucide="alert-circle" width="64" height="64" style="color: var(--color-attention-high); margin-bottom: 10px;"></i>
            <h3 id="notif-title" style="color: var(--color-attention-high);">Увага</h3>
            <p id="notif-body" style="margin: 15px 0; font-weight: 500;">...</p>
            <button class="btn-primary" style="margin-top: 10px;" onclick="closeNotification()">ЗРОЗУМІЛО</button>
        </div>
    </div>

    <div id="zone-prev" class="touch-zone" onclick="onPrevPage()"></div>
    <div id="zone-next" class="touch-zone" onclick="onNextPage()"></div>

    <div id="fs-controls">
        <div id="fs-page-info">
            <span id="fs_page_num">--</span> / <span id="fs_page_count">--</span>
        </div>
        <button id="fs-exit" onclick="exitFullScreen()">
            <i data-lucide="minimize" width="24" height="24"></i>
        </button>
        <button id="fs-hand" onclick="toggleHand()">
            <svg class="hand-timer-svg" viewBox="0 0 36 36">
                <path class="hand-timer-path" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" />
            </svg>
            <i data-lucide="hand" width="32" height="32"></i>
        </button>
    </div>

    <div id="pdf-container">
        <div id="hand-overlay" class="hidden bounce">
            <i data-lucide="hand" width="24" height="24" fill="#f59e0b" stroke="none"></i>
            <span id="hand-count">0</span>
        </div>
        <div class="canvas-wrapper">
            <canvas id="the-canvas"></canvas>
            <canvas id="draw-canvas"></canvas>
        </div>
    </div>

    <div id="toolbar">
        <button class="tool-btn" onclick="toggleQR()">
            <div class="btn-inner">
                <i data-lucide="qr-code" width="24" height="24"></i>
                <span>QR</span>
            </div>
        </button>

        <div class="tool-btn spk-only hidden" id="user-count-display">
            <div class="btn-inner">
                <i data-lucide="users" width="24" height="24"></i>
                <span id="user-count-val">0</span>
            </div>
        </div>

        <button class="tool-btn lst-only hidden" id="btn-hand" onclick="toggleHand()">
            <div class="btn-inner">
                <svg class="hand-timer-svg" viewBox="0 0 36 36">
                    <path class="hand-timer-path" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" />
                </svg>
                <i data-lucide="hand" width="24" height="24"></i>
                <span>Рука</span>
            </div>
        </button>
        
        <button class="tool-btn lst-only hidden" onclick="triggerResync()">
            <div class="btn-inner">
                <i data-lucide="refresh-cw" width="24" height="24"></i>
                <span id="resync-text">Оновити</span>
            </div>
        </button>

        <button class="tool-btn lst-only hidden" onclick="enterFullScreen()">
            <div class="btn-inner">
                <i data-lucide="maximize" width="24" height="24"></i>
                <span>Full</span>
            </div>
        </button>

        <button class="tool-btn spk-only hidden" id="prev" onclick="onPrevPage()">
            <div class="btn-inner">
                <i data-lucide="arrow-left" width="24" height="24"></i>
                <span>Назад</span>
            </div>
        </button>

        <div id="page-info">
            <span id="page_num">--</span> / <span id="page_count">--</span>
        </div>

        <button class="tool-btn spk-only hidden" id="next" onclick="onNextPage()">
            <div class="btn-inner">
                <i data-lucide="arrow-right" width="24" height="24"></i>
                <span>Далі</span>
            </div>
        </button>

        <button class="tool-btn" id="rotate" onclick="onRotate()">
            <div class="btn-inner">
                <i data-lucide="rotate-cw" width="24" height="24"></i>
                <span>Оберт</span>
            </div>
        </button>

        <button class="tool-btn danger spk-only hidden" id="eraser-btn" onclick="clearDrawings(true)">
            <div class="btn-inner">
                <i data-lucide="eraser" width="24" height="24"></i>
                <span>Стерти</span>
            </div>
        </button>
    </div>

    <script>
        const LANDSCAPE_ROTATION_DEG = 0; 
        const APP_PREFIX = "synchro_pdf_";
        const DEFAULT_PDF_URL = 'https://gitknu.github.io/webrtc_test/slides.pdf';
        
        let pdfDoc = null, pageNum = 1, pageRendering = false, pageNumPending = null;
        let rotation = 0;
        
        const pdfCanvas = document.getElementById('the-canvas');
        const pdfCtx = pdfCanvas.getContext('2d');
        const drawCanvas = document.getElementById('draw-canvas');
        const drawCtx = drawCanvas.getContext('2d');
        const container = document.getElementById('pdf-container');
        
        let peer = null;
        let connections = [];
        let isLeader = false;
        let transferInProgress = false;
        let activeSourceUrl = null;
        let myIdRaw = null;
        let currentHostId = null; 
        
        let myHandRaised = false;
        let hostConnection = null;
        let handTimeout = null;
        
        let isDrawing = false;
        let lastX = 0, lastY = 0;
        let pageMarks = {};

        const lockDigits = [0,0,0,0,0,0,0,0,0];
        let html5QrcodeScanner = null;

        lucide.createIcons();
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        window.onload = () => {
            document.documentElement.style.setProperty('--landscape-rotation', LANDSCAPE_ROTATION_DEG + 'deg');
            const params = new URLSearchParams(window.location.search);
            if (params.get('p')) {
                pageNum = parseInt(params.get('p')) || 1;
                renderPdf(DEFAULT_PDF_URL).catch(() => {});
            }
            if (params.get('host')) {
                document.getElementById('role-menu').classList.add('hidden');
                joinGame(params.get('host'));
            }
            initDrawingListeners();
            initLockInterface();
        };

        function initLockInterface() {
            for (let i = 0; i < 9; i++) {
                const col = document.getElementById('d' + i);
                if(col) {
                    col.innerHTML = `
                        <button class="digit-btn" onclick="changeDigit(${i}, 1)">
                            <i data-lucide="chevron-up" width="16" height="16"></i>
                        </button>
                        <div class="digit-display" id="digit-val-${i}">0</div>
                        <button class="digit-btn" onclick="changeDigit(${i}, -1)">
                            <i data-lucide="chevron-down" width="16" height="16"></i>
                        </button>
                    `;
                }
            }
            lucide.createIcons();
        }

        function changeDigit(index, delta) {
            let val = lockDigits[index];
            val = (val + delta + 10) % 10;
            lockDigits[index] = val;
            document.getElementById(`digit-val-${index}`).innerText = val;
        }

        function getLockCode() {
            return lockDigits.join('');
        }

        function resetInputColor() {
            const input = document.getElementById('gdrive-input');
            input.classList.remove('input-success');
            input.classList.remove('input-error');
        }

        function forceReload() { window.location.reload(); }

        function triggerResync() {
            if(hostConnection && hostConnection.open) {
                const btnIcon = document.querySelector('.btn-inner i[data-lucide="refresh-cw"]');
                if(btnIcon) btnIcon.classList.add('spin');
                hostConnection.send({ type: 'RESYNC_REQ' });
                setTimeout(() => { if(btnIcon) btnIcon.classList.remove('spin'); }, 1000);
            } else {
                 if(confirm("З'єднання втрачено. Перезавантажити сторінку?")) window.location.reload();
            }
        }

        function showNotification(msg, isError = false) {
            const modal = document.getElementById('notification-modal');
            const title = document.getElementById('notif-title');
            const body = document.getElementById('notif-body');
            const icon = modal.querySelector('i');
            if (isError) {
                title.innerText = "Помилка";
                icon.setAttribute('data-lucide', 'alert-circle');
                modal.querySelector('.modal-content').style.borderColor = 'var(--color-attention-high)';
                title.style.color = 'var(--color-attention-high)';
                icon.style.color = 'var(--color-attention-high)';
            } else {
                title.innerText = "Інформація";
                icon.setAttribute('data-lucide', 'info');
                modal.querySelector('.modal-content').style.borderColor = 'var(--color-attention-med)';
                title.style.color = 'var(--color-attention-med)';
                icon.style.color = 'var(--color-attention-med)';
            }
            body.innerText = msg;
            lucide.createIcons();
            modal.style.display = 'flex';
        }

        function closeNotification() { document.getElementById('notification-modal').style.display = 'none'; }

        function enterFullScreen() {
            document.body.classList.add('fullscreen-mode');
            const el = document.documentElement;
            if (el.requestFullscreen) el.requestFullscreen();
            else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
            else if (el.msRequestFullscreen) el.msRequestFullscreen();
            setTimeout(() => { if(pdfDoc) { clearDrawings(false); renderPage(pageNum); } }, 200);
        }

        function exitFullScreen() {
            document.body.classList.remove('fullscreen-mode');
            if (document.exitFullscreen) document.exitFullscreen();
            else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
            else if (document.msExitFullscreen) document.msExitFullscreen();
            setTimeout(() => { if(pdfDoc) { clearDrawings(false); renderPage(pageNum); } }, 200);
        }

        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement) {
                document.body.classList.remove('fullscreen-mode');
                if(pdfDoc) { clearDrawings(false); renderPage(pageNum); }
            }
        });

        function updateToolbarForRole() {
            const spkBtns = document.querySelectorAll('.spk-only');
            const lstBtns = document.querySelectorAll('.lst-only');
            if (isLeader) {
                spkBtns.forEach(el => el.classList.remove('hidden'));
                lstBtns.forEach(el => el.classList.add('hidden'));
                document.getElementById('zone-prev').style.display = 'block';
                document.getElementById('zone-next').style.display = 'block';
            } else {
                spkBtns.forEach(el => el.classList.add('hidden'));
                lstBtns.forEach(el => el.classList.remove('hidden'));
                document.getElementById('zone-prev').style.display = 'none';
                document.getElementById('zone-next').style.display = 'none';
            }
        }

        function setupListener() {
            document.getElementById('role-menu').classList.add('hidden');
            document.getElementById('listener-menu').classList.remove('hidden');
            isLeader = false;
            updateToolbarForRole();
            // Start scanner with constrained height config implicitly by container CSS
            // Increased qrbox size to match larger visual container
            html5QrcodeScanner = new Html5QrcodeScanner("reader", { fps: 10, qrbox: { width: 200, height: 200 }, aspectRatio: 1.0 }, false);
            html5QrcodeScanner.render(onScanSuccess, onScanFailure);
        }

        function onScanSuccess(decodedText) {
            let hostId = decodedText;
            let p = null;
            try {
                const url = new URL(decodedText);
                const params = new URLSearchParams(url.search);
                if(params.get('host')) hostId = params.get('host');
                if(params.get('p')) p = params.get('p');
            } catch(e) {}
            if(html5QrcodeScanner) html5QrcodeScanner.clear();
            joinGame(hostId, p);
        }

        function onScanFailure(error) { }

        function setupSpeaker() {
            document.getElementById('role-menu').classList.add('hidden');
            initLeader();
        }

        function normalizePresentationUrl(url) {
            if (!url) return null;
            if (url.includes('google.com')) {
                const idRegex = /\/d\/([a-zA-Z0-9_-]+)/;
                const match = url.match(idRegex);
                const id = match ? match[1] : null;
                if (id) {
                    if (url.includes('presentation')) return `https://docs.google.com/presentation/d/${id}/export/pdf`;
                    if (url.includes('document')) return `https://docs.google.com/document/d/${id}/export?format=pdf`;
                    if (url.includes('view') || url.includes('open') || url.includes('/file/d/')) return `https://drive.google.com/uc?export=download&id=${id}`;
                }
            }
            if (url.includes('dropbox.com')) return url.replace('www.dropbox.com', 'dl.dropboxusercontent.com').replace('?dl=0', '');
            if (url.includes('github.com') && url.includes('/blob/')) return url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
            if (url.includes('onedrive.live.com') || url.includes('1drv.ms')) {
                if (!url.includes('download=1')) {
                    if (url.includes('?')) return url + '&download=1';
                    else return url + '?download=1';
                }
            }
            return url;
        }

        function getOptimalScale(page) {
            const availableWidth = container.clientWidth - 20; 
            const availableHeight = container.clientHeight - 20;
            const viewport = page.getViewport({ scale: 1, rotation: rotation });
            const scaleX = availableWidth / viewport.width;
            const scaleY = availableHeight / viewport.height;
            return Math.min(scaleX, scaleY) * (window.devicePixelRatio || 1);
        }

        async function renderPdf(source) {
            if (typeof source === 'string' && (source.includes('.ppt') || source.includes('.pptx')) && !source.includes('google.com')) {
                showNotification("Браузер не відображає PPT/PPTX напряму. Будь ласка, використовуйте посилання на Google Slides або експортуйте файл у PDF.", true);
                return false;
            }
            try {
                const loadingTask = pdfjsLib.getDocument({
                    url: source,
                    cMapUrl: 'https://unpkg.com/pdfjs-dist@3.11.174/cmaps/',
                    cMapPacked: true
                });
                pdfDoc = await loadingTask.promise;
                const num = pdfDoc.numPages;
                document.getElementById('page_count').textContent = num;
                document.getElementById('fs_page_count').textContent = num; 
                renderPage(pageNum);
                return true;
            } catch (e) {
                console.error("PDF Load Failed:", e);
                showNotification("Не вдалося завантажити файл. Перевірте посилання.", true);
                return false;
            }
        }

        function renderPage(num) {
            if(pdfDoc && num > pdfDoc.numPages) num = pdfDoc.numPages;
            if(num < 1) num = 1;
            pageNum = num;

            pageRendering = true;
            pdfDoc.getPage(num).then(page => {
                const displayScale = getOptimalScale(page);
                const viewport = page.getViewport({ scale: displayScale, rotation: rotation });
                
                document.documentElement.style.setProperty('--landscape-rotation', rotation + 'deg');
                
                pdfCanvas.height = viewport.height;
                pdfCanvas.width = viewport.width;
                drawCanvas.height = viewport.height;
                drawCanvas.width = viewport.width;
                
                drawCtx.lineCap = 'round'; drawCtx.lineJoin = 'round';
                drawCtx.lineWidth = 4; drawCtx.strokeStyle = '#b80000'; 

                const renderContext = { canvasContext: pdfCtx, viewport: viewport };
                page.render(renderContext).promise.then(() => {
                    pageRendering = false;
                    redrawStoredLines(num);
                    if (pageNumPending !== null) {
                        renderPage(pageNumPending);
                        pageNumPending = null;
                    }
                });
            });

            document.getElementById('page_num').textContent = num;
            document.getElementById('fs_page_num').textContent = num;
            
            if(isLeader) {
                document.getElementById('prev').disabled = num <= 1;
                document.getElementById('next').disabled = num >= pdfDoc.numPages;
                updateQRCodes();
            }
            container.scrollTop = 0; 
            container.scrollLeft = 0;
        }

        function queueRenderPage(num) {
            if (pageRendering) pageNumPending = num; else renderPage(num);
        }

        function toggleHand() {
            if (!hostConnection) return;
            if (handTimeout) { clearTimeout(handTimeout); handTimeout = null; }
            myHandRaised = !myHandRaised;
            
            const btn = document.getElementById('btn-hand');
            if (myHandRaised) btn.classList.add('hand-active');
            else btn.classList.remove('hand-active');

            const fsBtn = document.getElementById('fs-hand');
            if (myHandRaised) fsBtn.classList.add('fs-btn-active');
            else fsBtn.classList.remove('fs-btn-active');
            
            hostConnection.send({ type: 'HAND', value: myHandRaised });

            if (myHandRaised) {
                handTimeout = setTimeout(() => {
                    myHandRaised = false;
                    document.getElementById('btn-hand').classList.remove('hand-active');
                    document.getElementById('fs-hand').classList.remove('fs-btn-active');
                    if (hostConnection) { hostConnection.send({ type: 'HAND', value: false }); }
                    handTimeout = null;
                }, 10000);
            }
        }

        function updateHandOverlay() {
            if (!isLeader) return;
            const count = connections.filter(c => c.handRaised).length;
            const overlay = document.getElementById('hand-overlay');
            const counter = document.getElementById('hand-count');
            counter.innerText = count;
            if (count > 0) overlay.classList.remove('hidden');
            else overlay.classList.add('hidden');
        }

        function initDrawingListeners() {
            drawCanvas.addEventListener('mousedown', startDrawing);
            drawCanvas.addEventListener('mousemove', draw);
            drawCanvas.addEventListener('mouseup', stopDrawing);
            drawCanvas.addEventListener('mouseout', stopDrawing);
            drawCanvas.addEventListener('touchstart', (e) => {
                if(e.touches.length === 1) { e.preventDefault(); startDrawing(e.touches[0]); }
            });
            drawCanvas.addEventListener('touchmove', (e) => {
                if(e.touches.length === 1) { e.preventDefault(); draw(e.touches[0]); }
            });
            drawCanvas.addEventListener('touchend', stopDrawing);
        }

        function getPos(e) {
            const rect = drawCanvas.getBoundingClientRect();
            return {
                x: (e.clientX - rect.left) * (drawCanvas.width / rect.width),
                y: (e.clientY - rect.top) * (drawCanvas.height / rect.height)
            };
        }

        function startDrawing(e) {
            if (!isLeader) return;
            isDrawing = true;
            const pos = getPos(e);
            lastX = pos.x; lastY = pos.y;
            performDraw(lastX, lastY, lastX, lastY, true);
        }

        function draw(e) {
            if (!isDrawing || !isLeader) return;
            const pos = getPos(e);
            performDraw(lastX, lastY, pos.x, pos.y, true);
            lastX = pos.x; lastY = pos.y;
        }

        function stopDrawing() { isDrawing = false; }

        function performDraw(x0, y0, x1, y1, emit) {
            const w = drawCanvas.width; const h = drawCanvas.height;
            drawCtx.beginPath();
            drawCtx.moveTo(x0, y0); drawCtx.lineTo(x1, y1); drawCtx.stroke();
            if (emit && isLeader) {
                const normCoords = [x0 / w, y0 / h, x1 / w, y1 / h];
                if (!pageMarks[pageNum]) pageMarks[pageNum] = [];
                pageMarks[pageNum].push(normCoords);
                broadcast({ type: 'DRAW', coords: normCoords });
            }
        }

        function receiveDraw(nx0, ny0, nx1, ny1) {
            const w = drawCanvas.width; const h = drawCanvas.height;
            if (!pageMarks[pageNum]) pageMarks[pageNum] = [];
            pageMarks[pageNum].push([nx0, ny0, nx1, ny1]);
            drawCtx.beginPath();
            drawCtx.moveTo(nx0 * w, ny0 * h); drawCtx.lineTo(nx1 * w, ny1 * h); drawCtx.stroke();
        }

        function redrawStoredLines(pNum) {
            if (!pageMarks[pNum]) return;
            const w = drawCanvas.width; const h = drawCanvas.height;
            drawCtx.lineCap = 'round'; drawCtx.lineJoin = 'round';
            drawCtx.lineWidth = 4; drawCtx.strokeStyle = '#b80000';
            drawCtx.beginPath();
            pageMarks[pNum].forEach(line => {
                drawCtx.moveTo(line[0] * w, line[1] * h);
                drawCtx.lineTo(line[2] * w, line[3] * h);
            });
            drawCtx.stroke();
        }

        function clearDrawings(emit) {
            drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            if (emit) {
                pageMarks[pageNum] = [];
                if (isLeader) broadcast({ type: 'CLEAR' });
            }
        }

        function onPrevPage() {
            if (!pdfDoc || pageNum <= 1) return;
            pageNum--;
            clearDrawings(false);
            queueRenderPage(pageNum);
            if (isLeader) broadcast({ type: 'PAGE', value: pageNum });
        }

        function onNextPage() {
            if (!pdfDoc || pageNum >= pdfDoc.numPages) return;
            pageNum++;
            clearDrawings(false);
            queueRenderPage(pageNum);
            if (isLeader) broadcast({ type: 'PAGE', value: pageNum });
        }

        function onRotate() {
            rotation += 90;
            if (rotation >= 360) rotation = 0;
            clearDrawings(false); queueRenderPage(pageNum);
        }

        function toggleQR() {
            const modal = document.getElementById('qr-modal');
            modal.style.display = (modal.style.display === 'flex') ? 'none' : 'flex';
        }
        
        function formatId(id) {
            if (!id) return "...";
            return id.replace(/(\d{3})(\d{3})(\d{3})/, "$1 $2 $3");
        }

        function updateQRCodes() {
            if(!myIdRaw) return;
            const baseUrl = window.location.href.split('?')[0];
            const fullUrl = `${baseUrl}?host=${myIdRaw}&p=${pageNum}`;
            
            document.getElementById("qr-container").innerHTML = "";
            document.getElementById("qrcode-modal-tgt").innerHTML = "";
            document.getElementById("qr-page-num").innerText = pageNum;
            
            const fmtId = formatId(myIdRaw);
            document.getElementById('meeting-id-display').innerText = fmtId;
            document.getElementById('qr-modal-id').innerText = fmtId;

            // Generate small QR for speaker menu, larger for modal
            new QRCode(document.getElementById("qr-container"), { text: fullUrl, width: 250, height: 250, colorDark: "#000000" });
            new QRCode(document.getElementById("qrcode-modal-tgt"), { text: fullUrl, width: 250, height: 250, colorDark: "#000000" });
        }

        function enterOfflineMode() {
            document.getElementById('ui-layer').classList.add('hidden');
            document.getElementById('offline-indicator').classList.remove('hidden');
            document.getElementById('prev').classList.remove('hidden');
            document.getElementById('next').classList.remove('hidden');
            document.getElementById('zone-prev').style.display = 'block';
            document.getElementById('zone-next').style.display = 'block';
        }

        function exitOfflineMode() {
            document.getElementById('offline-indicator').classList.add('hidden');
            document.getElementById('prev').classList.add('hidden');
            document.getElementById('next').classList.add('hidden');
            document.getElementById('zone-prev').style.display = 'none';
            document.getElementById('zone-next').style.display = 'none';
        }

        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if(pdfDoc) { clearDrawings(false); renderPage(pageNum); }
            }, 200);
        });

        function generateShortId() {
            const min = 100000000;
            const max = 999999999;
            return Math.floor(Math.random() * (max - min + 1) + min).toString();
        }

        function initLeader() {
            isLeader = true;
            updateToolbarForRole();
            document.getElementById('speaker-menu').classList.remove('hidden');
            drawCanvas.style.pointerEvents = 'auto';

            myIdRaw = generateShortId();
            const peerJsId = APP_PREFIX + myIdRaw;

            peer = new Peer(peerJsId);

            peer.on('open', id => {
                updateQRCodes();
                document.getElementById('btn-start-sync').disabled = false;
            });

            peer.on('error', (err) => {
                if(err.type === 'unavailable-id') {
                    peer.destroy();
                    setTimeout(initLeader, 200);
                } else {
                    showNotification("Помилка з'єднання: " + err.type, true);
                }
            });

            setInterval(() => {
                if(!isLeader) return;
                connections.forEach(c => {
                    if(c.conn.open) {
                        c.conn.send({ type: 'HEARTBEAT', page: pageNum });
                    }
                });
                
                const now = Date.now();
                const beforeCount = connections.length;
                connections = connections.filter(c => (now - c.lastPong) < 10000);
                
                if(connections.length !== beforeCount) {
                    updateClientList();
                    updateHandOverlay();
                }
            }, 2000);

            peer.on('connection', conn => {
                connections = connections.filter(c => c.id !== conn.peer);
                const client = { 
                    id: conn.peer, 
                    conn: conn, 
                    ready: false, 
                    handRaised: false,
                    lastPong: Date.now() 
                };
                connections.push(client);
                updateClientList();

                conn.on('open', () => {
                    if (transferInProgress) {
                        syncSingleClient(client);
                    }
                });

                conn.on('data', data => {
                    client.lastPong = Date.now();
                    
                    if (data.type === 'PONG') return; 

                    if (data.type === 'ACK_READY') {
                        client.ready = true;
                        updateClientList();
                        if(transferInProgress) {
                            conn.send({ type: 'PAGE', value: pageNum });
                            if(pageMarks[pageNum]) {
                                pageMarks[pageNum].forEach(line => {
                                   conn.send({ type: 'DRAW', coords: line }); 
                                });
                            }
                        }
                    }
                    if (data.type === 'HAND') {
                        client.handRaised = data.value;
                        updateHandOverlay();
                    }
                    if (data.type === 'RESYNC_REQ') {
                        conn.send({ type: 'PAGE', value: pageNum });
                        if(pageMarks[pageNum]) {
                            pageMarks[pageNum].forEach(line => {
                                conn.send({ type: 'DRAW', coords: line });
                            });
                        }
                    }
                });

                conn.on('close', () => {
                    connections = connections.filter(c => c.conn !== conn);
                    updateClientList();
                    updateHandOverlay();
                });
            });
        }

        function updateClientList() {
            document.getElementById('user-count-val').innerText = connections.length;
            document.getElementById('speaker-user-count').innerText = connections.length;
            
            if(!transferInProgress) {
                document.getElementById('btn-start-sync').innerHTML = `<i data-lucide="play" width="28" height="28"></i>`;
                lucide.createIcons();
            }
        }

        async function startDistribution() {
            resetInputColor();
            const inputField = document.getElementById('gdrive-input');
            const driveInput = inputField.value.trim();
            activeSourceUrl = normalizePresentationUrl(driveInput) || DEFAULT_PDF_URL;

            const lbl = document.getElementById('sync-status');
            lbl.style.display = 'block';
            document.getElementById('btn-start-sync').disabled = true;

            const success = await renderPdf(activeSourceUrl);
            
            if (success) {
                inputField.classList.add('input-success');
                transferInProgress = true;
                document.getElementById('ui-layer').classList.add('hidden');
                connections.forEach(c => syncSingleClient(c));
            } else {
                inputField.classList.add('input-error');
                lbl.style.display = 'none';
                document.getElementById('btn-start-sync').disabled = false;
            }
        }

        function syncSingleClient(client) {
            client.ready = false;
            updateClientList();
            if (!client.conn.open) return;
            client.conn.send({ type: 'INIT', url: activeSourceUrl });
        }

        function broadcast(msg) {
            connections.forEach(c => { if(c.conn.open) c.conn.send(msg); });
        }

        function joinGame(id, pageParam) {
            let hostId = id || getLockCode(); 
            hostId = hostId.replace(/\s/g, '');
            if (!hostId) return showNotification("Потрібен ID або QR код для підключення", true);
            if (!hostId.startsWith(APP_PREFIX)) hostId = APP_PREFIX + hostId;

            currentHostId = hostId.replace(APP_PREFIX, ''); 
            const newUrl = window.location.protocol + "//" + window.location.host + window.location.pathname + '?host=' + currentHostId;
            window.history.replaceState({path: newUrl}, '', newUrl);

            if(pageParam) pageNum = parseInt(pageParam);

            document.getElementById('listener-menu').classList.add('hidden');
            document.getElementById('loading-menu').classList.remove('hidden');
            isLeader = false;
            updateToolbarForRole();

            if(pageParam) enterOfflineMode();
            if(html5QrcodeScanner) try { html5QrcodeScanner.clear(); } catch(e){}

            peer = new Peer();
            peer.on('open', () => {
                const conn = peer.connect(hostId, { reliable: true });
                hostConnection = conn;

                conn.on('open', () => document.getElementById('loading-msg').innerText = "Пошук ведучого...");
                
                peer.on('error', (err) => {
                   if(err.type === 'peer-unavailable') {
                       showNotification('Ведучого з таким ID не знайдено', true);
                       setTimeout(() => location.reload(), 3000);
                   }
                });

                conn.on('data', async data => {
                    if (data.type === 'HEARTBEAT') {
                        conn.send({ type: 'PONG' });
                        if(pdfDoc && !pageRendering && pageNum !== data.page) {
                            pageNum = data.page;
                            clearDrawings(false); 
                            queueRenderPage(pageNum);
                            conn.send({ type: 'RESYNC_REQ' });
                        }
                        return;
                    }
                    if (data.type === 'INIT') {
                        document.getElementById('loading-msg').innerText = "Завантаження презентації...";
                        const ok = await renderPdf(data.url);
                        if(ok) finishSetup();
                    }
                    if (data.type === 'PAGE') {
                        pageNum = data.value;
                        clearDrawings(false); if(pdfDoc) queueRenderPage(pageNum);
                    }
                    if (data.type === 'DRAW') receiveDraw(data.coords[0], data.coords[1], data.coords[2], data.coords[3]);
                    if (data.type === 'CLEAR') clearDrawings(true);
                });

                function finishSetup() {
                    conn.send({ type: 'ACK_READY' });
                    exitOfflineMode();
                    document.getElementById('ui-layer').classList.add('hidden');
                    
                    const cleanHost = hostId.replace(APP_PREFIX, '');
                    const currentUrl = window.location.href.split('?')[0] + '?host=' + cleanHost;
                    
                    document.getElementById('qr-modal-id').innerText = formatId(cleanHost);
                    document.getElementById("qrcode-modal-tgt").innerHTML = "";
                    new QRCode(document.getElementById("qrcode-modal-tgt"), { text: currentUrl, width: 250, height: 250, colorDark: "#000000" });
                }
                
                conn.on('close', () => { });
            });
        }
    </script>
</body>
</html>
