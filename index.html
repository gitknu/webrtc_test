<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Синхро PDF</title>
    
    <!-- Fonts: Montserrat -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700;800&display=swap" rel="stylesheet">

    <!-- Libraries -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://unpkg.com/html5-qrcode" type="text/javascript"></script>
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        :root {
            /* Functional Color Palette */
            --color-bg: #f4f4f4;
            --color-card: #ffffff;
            
            /* ATTENTION COLORS */
            --color-attention-high: #b80000; /* Red: Main Actions, Listener */
            --color-attention-med: #0b5394;  /* Blue: Secondary Actions, Speaker, Inputs */
            --color-hand: #f59e0b; /* Amber for Hand Raise */
            
            --color-text: #000000;
            --color-border: #cccccc;
            --shadow: 0 4px 20px rgba(0,0,0,0.15);
        }

        * { box-sizing: border-box; touch-action: manipulation; -webkit-tap-highlight-color: transparent; }

        body {
            margin: 0; padding: 0;
            background-color: var(--color-bg);
            color: var(--color-text);
            font-family: 'Montserrat', sans-serif;
            font-size: 16px;
            overflow: hidden; 
            height: 100vh; width: 100vw;
            display: flex; flex-direction: column;
        }

        /* --- UI OVERLAYS --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(244, 244, 244, 1); z-index: 200;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            padding: 15px;
        }
        
        .card {
            background: var(--color-card); 
            color: var(--color-text);
            padding: 1.5rem; 
            border-radius: 1.2rem;
            text-align: center; 
            width: 100%; max-width: 450px;
            /* Responsiveness: Fit screen, scroll inside only if needed */
            max-height: 95vh; 
            overflow-y: auto; 
            box-shadow: var(--shadow);
            border: 2px solid var(--color-border);
            display: flex; flex-direction: column; gap: 1rem;
        }
        
        .hidden { display: none !important; }

        h3 { 
            margin: 0;
            color: var(--color-text); 
            font-weight: 700;
            font-size: 1.4rem;
        }

        p { margin: 0; font-size: 1rem; color: var(--color-text); line-height: 1.4; }
        
        /* --- ROLE BUTTONS (Adaptive Layout) --- */
        #role-menu {
            display: flex; flex-direction: column; gap: 15px;
            width: 100%; max-width: 500px;
            height: 100%; 
            padding: 10px 0;
            justify-content: center;
        }

        .role-btn {
            flex: 1; /* Grow to fill space */
            max-height: 45vh; /* Don't get too tall on tablets */
            border: none; border-radius: 1.2rem;
            font-family: 'Montserrat', sans-serif;
            font-size: clamp(1.5rem, 5vw, 2.2rem); /* Responsive Font */
            font-weight: 800;
            color: white; cursor: pointer;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            gap: 15px;
            box-shadow: 0 6px 15px rgba(0,0,0,0.2);
            transition: transform 0.1s;
            text-transform: uppercase;
        }

        .role-btn:active { transform: scale(0.97); }
        
        /* RED: Listener (Main Role) */
        .role-listener { 
            background-color: var(--color-attention-high); 
            border: 2px solid var(--color-attention-high);
        }
        
        /* BLUE: Speaker (Secondary Role) */
        .role-speaker { 
            background-color: var(--color-attention-med); 
            border: 2px solid var(--color-attention-med);
        }
        
        /* --- BUTTONS & INPUTS --- */
        
        /* Primary Action (RED) */
        button.btn-primary {
            background: var(--color-attention-high); 
            color: white; border: none;
            padding: 1rem; 
            font-size: 1.1rem; 
            font-family: 'Montserrat', sans-serif;
            font-weight: 700;
            border-radius: 0.8rem;
            cursor: pointer; width: 100%;
            display: flex; align-items: center; justify-content: center; gap: 10px;
            box-shadow: 0 4px 10px rgba(184, 0, 0, 0.3);
            text-transform: uppercase;
            flex-shrink: 0; /* Prevent crushing */
        }
        button.btn-primary:active { transform: scale(0.98); }
        button.btn-primary:disabled { opacity: 0.5; cursor: not-allowed; box-shadow: none; }

        /* Secondary Action (BLUE/WHITE) */
        button.btn-secondary { 
            background: white; 
            color: var(--color-attention-med); 
            border: 2px solid var(--color-attention-med); 
            padding: 0.8rem;
            font-size: 1rem;
            font-weight: 600;
            border-radius: 0.8rem;
            cursor: pointer; width: 100%;
            display: flex; align-items: center; justify-content: center; gap: 8px;
            font-family: 'Montserrat', sans-serif;
            flex-shrink: 0;
        }
        button.btn-secondary:active { background: #f0f8ff; }

        /* Inputs (BLUE Focus) */
        input[type="text"] {
            padding: 1rem; width: 100%;
            background: #fff; 
            border: 2px solid var(--color-attention-med);
            color: var(--color-attention-med); 
            border-radius: 0.8rem; 
            outline: none;
            font-size: 1.1rem; text-align: center;
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            flex-shrink: 0;
        }
        input[type="text"]::placeholder { color: #88a; font-weight: 400; }
        input[type="file"] { display: none; }

        /* --- QR SCANNER CUSTOMIZATION --- */
        #reader {
            width: 100%;
            border-radius: 1rem;
            overflow: hidden;
            background: #000;
            border: 3px solid var(--color-attention-med);
            flex-shrink: 0; /* Important: don't collapse */
            min-height: 200px;
        }
        #reader video { object-fit: cover; border-radius: 1rem; }
        
        /* Force Library Button to be Red */
        #reader button {
            background-color: var(--color-attention-high) !important;
            color: white !important;
            border: none !important;
            padding: 1rem !important;
            border-radius: 0.5rem !important;
            font-family: 'Montserrat', sans-serif !important;
            font-weight: 600 !important;
            margin-top: 10px !important;
            width: 100% !important;
        }
        
        #html5-qrcode-button-camera-stop, 
        #html5-qrcode-anchor-scan-type-change, 
        #reader__dashboard_section_csr span { display: none !important; }

        /* --- PDF VIEWER --- */
        #pdf-container {
            flex: 1; overflow: auto;
            display: flex; justify-content: center; align-items: flex-start;
            padding: 1rem 0.5rem 80px 0.5rem; /* Space for toolbar */
            position: relative;
            background: #e0e0e0;
            width: 100%;
        }

        .canvas-wrapper {
            position: relative;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            background: white;
        }
        
        canvas#the-canvas { display: block; max-width: 100%; height: auto; }
        canvas#draw-canvas {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            touch-action: none; cursor: crosshair;
            pointer-events: none; 
        }

        /* HAND OVERLAY (Speaker View) */
        #hand-overlay {
            position: absolute; top: 10px; left: 10px;
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid var(--color-hand);
            border-radius: 20px;
            padding: 8px 16px;
            display: flex; align-items: center; gap: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 50;
            font-weight: 700; color: #000;
        }
        .bounce { animation: bounce 0.5s infinite alternate; }
        @keyframes bounce { from { transform: translateY(0); } to { transform: translateY(-5px); } }

        .touch-zone { position: fixed; top: 0; bottom: 80px; width: 15%; z-index: 10; }
        #zone-prev { left: 0; }
        #zone-next { right: 0; }

        /* QR Modal */
        #qr-modal {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255,255,255,0.98); z-index: 300;
            justify-content: center; align-items: center; flex-direction: column;
            padding: 20px;
        }
        #qr-code-box { 
            background: white; padding: 1.5rem; border-radius: 1.5rem; 
            box-shadow: var(--shadow); border: 2px solid var(--color-attention-med);
            display: flex; flex-direction: column; align-items: center;
        }

        /* --- COMPACT TOOLBAR --- */
        #toolbar {
            position: fixed; bottom: 0; left: 0; width: 100%; height: 75px;
            background-color: var(--color-attention-med);
            /* Center elements with gap instead of space-around to prevent overflow */
            display: flex; justify-content: center; align-items: center;
            gap: 4px; /* Tight gap */
            box-shadow: 0 -4px 15px rgba(0,0,0,0.2); z-index: 20;
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: 2px; padding-right: 2px;
        }

        #page-info { 
            color: white; font-size: 1rem; font-weight: 600; 
            min-width: 45px; text-align: center; 
            white-space: nowrap; 
            margin: 0 2px;
        }

        .tool-btn {
            background: none; border: none; color: white; cursor: pointer;
            padding: 4px 2px; /* Minimized padding */
            border-radius: 0.5rem;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            min-width: 44px; /* Compact width */
            flex-shrink: 1;
        }
        .tool-btn:active { background-color: rgba(255,255,255,0.2); }
        .tool-btn span { font-size: 0.65rem; margin-top: 3px; font-weight: 500; }
        
        .tool-btn.danger { color: #ffcccc; } 
        
        /* Active Hand State (Listener) */
        .hand-active { color: var(--color-hand) !important; background: rgba(255,255,255,0.1); }
        .hand-active i { fill: var(--color-hand); }

        .file-label {
            font-size: 0.9rem; color: var(--color-attention-med); 
            word-break: break-all; font-weight: 600;
            padding: 10px; border: 2px dashed var(--color-attention-med);
            border-radius: 0.8rem; background: rgba(11, 83, 148, 0.05);
        }
        
        #client-list {
            text-align: left; max-height: 150px; overflow-y: auto;
            background: #f9f9f9; border: 1px solid #eee;
            border-radius: 0.8rem; padding: 0.5rem; margin: 0;
            width: 100%; flex-grow: 1; /* Fill available space in card */
        }
        .client-row { 
            display: flex; justify-content: space-between; 
            padding: 0.8rem; border-bottom: 1px solid #eee; 
            font-size: 0.9rem; font-weight: 600;
        }
        .status-ready { color: var(--color-attention-high); font-weight: 700; }
        .status-wait { color: var(--color-attention-med); }

    </style>
</head>
<body>

    <!-- 1. UI LAYER -->
    <div id="ui-layer">
        
        <!-- STEP 1: ROLE SELECTION -->
        <div id="role-menu">
            <!-- RED: Main Role -->
            <button class="role-btn role-listener" onclick="setupListener()">
                <i data-lucide="ear" width="72" height="72"></i>
                Я СЛУХАЧ
            </button>
            <!-- BLUE: Secondary Role -->
            <button class="role-btn role-speaker" onclick="setupSpeaker()">
                <i data-lucide="mic-2" width="72" height="72"></i>
                Я ВЕДУЧИЙ
            </button>
        </div>

        <!-- STEP 2A: LISTENER SETUP -->
        <div id="listener-menu" class="card hidden">
            <button class="btn-secondary" onclick="location.reload()" style="width: auto; align-self: flex-start;">
                <i data-lucide="arrow-left"></i> Назад
            </button>

            <h3>Підключення</h3>
            
            <!-- Camera Container -->
            <div id="reader"></div> 
            
            <p>Наведіть камеру на QR код</p>
            
            <div style="width:100%; height:1px; background:#eee;"></div>

            <!-- BLUE: Input -->
            <input type="text" id="join-input" placeholder="Або введіть ID вручну">
            
            <!-- RED: Main Join Action -->
            <button class="btn-primary" onclick="joinGame()">
                <i data-lucide="link"></i> ПРИЄДНАТИСЬ
            </button>
        </div>

        <!-- STEP 2B: SPEAKER SETUP -->
        <div id="speaker-menu" class="card hidden">
            <button class="btn-secondary" onclick="location.reload()" style="width: auto; align-self: flex-start;">
                <i data-lucide="arrow-left"></i> Назад
            </button>
            
            <h3>Кабінет Ведучого</h3>
            
            <!-- QR & ID -->
            <div id="qr-container" style="background:white; padding:10px; display:inline-block; border: 2px solid var(--color-attention-med); border-radius: 10px;"></div>
            
            <input type="text" id="share-link" readonly onclick="this.select()" style="font-size: 0.9rem; padding: 0.8rem; background: #f0f0f0;">

            <!-- Users -->
            <div id="client-list">
                <div style="padding:15px; text-align:center; color:#888;">Чекаємо глядачів...</div>
            </div>

            <!-- File Upload (BLUE - Secondary) -->
            <div style="width: 100%; display: flex; flex-direction: column; gap: 8px;">
                <div id="file-name" class="file-label hidden"></div>
                <button class="btn-secondary" onclick="document.getElementById('file-upload').click()">
                    <i data-lucide="upload"></i> ОБРАТИ СВІЙ ФАЙЛ
                </button>
                <input type="file" id="file-upload" accept="application/pdf" onchange="handleFileSelect(this)">
            </div>

            <!-- Start Button (RED - Main Action) -->
            <button id="btn-start-sync" onclick="startDistribution()" class="btn-primary" disabled>
                <i data-lucide="play"></i> ПОЧАТИ ВИСТУП
            </button>
            
            <div id="sync-status" style="display:none; color: var(--color-attention-high); font-weight:700; font-size: 1.1rem;">
                <i data-lucide="loader-2" class="spin"></i> Завантаження...
            </div>
        </div>

        <!-- LOADING SCREEN -->
        <div id="loading-menu" class="card hidden" style="justify-content: center; border-color: var(--color-attention-med);">
            <i data-lucide="loader-2" class="spin" style="animation: spin 1s linear infinite; color: var(--color-attention-med); width:64px; height:64px;"></i>
            <h3 id="loading-msg">З'єднання...</h3>
            <div id="progress-bar-container" style="width: 100%; background: #ddd; height: 16px; border-radius: 8px; overflow: hidden; display: none;">
                <div id="progress-bar-fill" style="height: 100%; background: var(--color-attention-med); width: 0%; transition: width 0.2s;"></div>
            </div>
            <div id="status-text" style="font-size:1.1rem; color:#666; font-weight: 600;"></div>
        </div>
    </div>

    <!-- 2. MAIN VIEWER -->
    
    <!-- QR Modal -->
    <div id="qr-modal" onclick="toggleQR()">
        <div id="qr-code-box" onclick="event.stopPropagation()">
            <h3 style="margin-bottom: 15px;">Поділитися</h3>
            <div id="qrcode-modal-tgt"></div>
            <button class="btn-secondary" style="margin-top:20px;" onclick="toggleQR()">ЗАКРИТИ</button>
        </div>
    </div>

    <!-- Invisible Click Zones (Speaker Only technically, but kept for logic) -->
    <div id="zone-prev" class="touch-zone" onclick="onPrevPage()"></div>
    <div id="zone-next" class="touch-zone" onclick="onNextPage()"></div>

    <!-- PDF Container -->
    <div id="pdf-container">
        <!-- Hand Overlay (Speaker View) -->
        <div id="hand-overlay" class="hidden bounce">
            <i data-lucide="hand" width="24" height="24" fill="#f59e0b" stroke="none"></i>
            <span id="hand-count">0</span>
        </div>

        <div class="canvas-wrapper">
            <canvas id="the-canvas"></canvas>
            <canvas id="draw-canvas"></canvas>
        </div>
    </div>

    <!-- Toolbar -->
    <div id="toolbar">
        <!-- Common -->
        <button class="tool-btn" onclick="toggleQR()">
            <i data-lucide="qr-code" width="24" height="24"></i>
            <span>QR</span>
        </button>

        <!-- Speaker: Users Count -->
        <div class="tool-btn spk-only hidden" id="user-count-display">
            <i data-lucide="users" width="24" height="24"></i>
            <span id="user-count-val">0</span>
        </div>

        <!-- Listener: Raise Hand -->
        <button class="tool-btn lst-only hidden" id="btn-hand" onclick="toggleHand()">
            <i data-lucide="hand" width="24" height="24"></i>
            <span>Рука</span>
        </button>

        <!-- Speaker: Prev -->
        <button class="tool-btn spk-only hidden" id="prev" onclick="onPrevPage()">
            <i data-lucide="arrow-left" width="24" height="24"></i>
            <span>Назад</span>
        </button>

        <!-- Common: Page Info -->
        <div id="page-info">
            <span id="page_num">--</span> / <span id="page_count">--</span>
        </div>

        <!-- Speaker: Next -->
        <button class="tool-btn spk-only hidden" id="next" onclick="onNextPage()">
            <i data-lucide="arrow-right" width="24" height="24"></i>
            <span>Далі</span>
        </button>

        <!-- Common: Rotate -->
        <button class="tool-btn" id="rotate" onclick="onRotate()">
            <i data-lucide="rotate-cw" width="24" height="24"></i>
            <span>Оберт</span>
        </button>

        <!-- Speaker: Clear -->
        <button class="tool-btn danger spk-only hidden" id="eraser-btn" onclick="clearDrawings(true)">
            <i data-lucide="eraser" width="24" height="24"></i>
            <span>Стерти</span>
        </button>
    </div>

    <script>
        // --- CONFIG & GLOBALS ---
        const DEFAULT_PDF_URL = 'https://gitknu.github.io/webrtc_test/slides.pdf';
        const CHUNK_SIZE = 16 * 1024;
        
        let pdfDoc = null, pageNum = 1, pageRendering = false, pageNumPending = null;
        let rotation = 0;
        
        const pdfCanvas = document.getElementById('the-canvas');
        const pdfCtx = pdfCanvas.getContext('2d');
        const drawCanvas = document.getElementById('draw-canvas');
        const drawCtx = drawCanvas.getContext('2d');
        const container = document.getElementById('pdf-container');
        
        let peer = null;
        let connections = []; // { id, conn, ready, handRaised }
        let isLeader = false;
        let transferInProgress = false;
        let leaderPdfBlob = null;
        
        // Listener specific globals
        let myHandRaised = false;
        let hostConnection = null;
        
        let incomingChunks = []; 
        let incomingSize = 0;
        let totalExpectedSize = 0;

        let isDrawing = false;
        let lastX = 0, lastY = 0;
        let pageMarks = {};

        let html5QrcodeScanner = null;

        lucide.createIcons();
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        window.onload = () => {
            const params = new URLSearchParams(window.location.search);
            if (params.get('host')) {
                document.getElementById('role-menu').classList.add('hidden');
                joinGame(params.get('host'));
            }
            initDrawingListeners();
        };

        // --- UI FLOW & TOOLBAR ---
        function updateToolbarForRole() {
            const spkBtns = document.querySelectorAll('.spk-only');
            const lstBtns = document.querySelectorAll('.lst-only');
            
            if (isLeader) {
                spkBtns.forEach(el => el.classList.remove('hidden'));
                lstBtns.forEach(el => el.classList.add('hidden'));
                // Disable touch zones for listeners? No, speaker needs them.
                document.getElementById('zone-prev').style.display = 'block';
                document.getElementById('zone-next').style.display = 'block';
            } else {
                spkBtns.forEach(el => el.classList.add('hidden'));
                lstBtns.forEach(el => el.classList.remove('hidden'));
                // Remove Prev/Next touch zones for listeners (view only)
                document.getElementById('zone-prev').style.display = 'none';
                document.getElementById('zone-next').style.display = 'none';
            }
        }

        function setupListener() {
            document.getElementById('role-menu').classList.add('hidden');
            document.getElementById('listener-menu').classList.remove('hidden');
            isLeader = false;
            updateToolbarForRole();

            html5QrcodeScanner = new Html5QrcodeScanner("reader", { fps: 10, qrbox: { width: 250, height: 250 }, aspectRatio: 1.0 }, false);
            html5QrcodeScanner.render(onScanSuccess, onScanFailure);
        }

        function onScanSuccess(decodedText) {
            let hostId = decodedText;
            try {
                const url = new URL(decodedText);
                const params = new URLSearchParams(url.search);
                if(params.get('host')) hostId = params.get('host');
            } catch(e) {}
            
            if(html5QrcodeScanner) html5QrcodeScanner.clear();
            joinGame(hostId);
        }

        function onScanFailure(error) { /* Ignore */ }

        function setupSpeaker() {
            document.getElementById('role-menu').classList.add('hidden');
            initLeader();
        }

        function handleFileSelect(input) {
            if (input.files[0]) {
                leaderPdfBlob = input.files[0];
                const lbl = document.getElementById('file-name');
                lbl.innerText = "Файл: " + leaderPdfBlob.name;
                lbl.classList.remove('hidden');
            }
        }

        // --- PDF ENGINE ---
        function getOptimalScale(page) {
            const containerWidth = container.clientWidth - 10; 
            const viewport = page.getViewport({ scale: 1, rotation: rotation });
            return (containerWidth / viewport.width) * (window.devicePixelRatio || 1);
        }

        async function renderPdf(source) {
            try {
                const loadingTask = pdfjsLib.getDocument(source);
                pdfDoc = await loadingTask.promise;
                document.getElementById('page_count').textContent = pdfDoc.numPages;
                renderPage(pageNum);
                return true;
            } catch (e) {
                alert("Помилка PDF: " + e.message);
                return false;
            }
        }

        function renderPage(num) {
            pageRendering = true;
            pdfDoc.getPage(num).then(page => {
                const displayScale = getOptimalScale(page);
                const viewport = page.getViewport({ scale: displayScale, rotation: rotation });
                
                pdfCanvas.height = viewport.height;
                pdfCanvas.width = viewport.width;
                drawCanvas.height = viewport.height;
                drawCanvas.width = viewport.width;
                
                drawCtx.lineCap = 'round'; drawCtx.lineJoin = 'round';
                drawCtx.lineWidth = 4; drawCtx.strokeStyle = '#b80000'; 

                const renderContext = { canvasContext: pdfCtx, viewport: viewport };
                page.render(renderContext).promise.then(() => {
                    pageRendering = false;
                    redrawStoredLines(num);
                    if (pageNumPending !== null) {
                        renderPage(pageNumPending);
                        pageNumPending = null;
                    }
                });
            });

            document.getElementById('page_num').textContent = num;
            
            // Only update buttons if leader (listeners don't have these buttons)
            if(isLeader) {
                document.getElementById('prev').disabled = num <= 1;
                document.getElementById('next').disabled = num >= pdfDoc.numPages;
            }
            container.scrollTop = 0; 
        }

        function queueRenderPage(num) {
            if (pageRendering) pageNumPending = num; else renderPage(num);
        }

        // --- HANDLER LOGIC ---
        function toggleHand() {
            if (!hostConnection) return;
            myHandRaised = !myHandRaised;
            
            // Update UI
            const btn = document.getElementById('btn-hand');
            if (myHandRaised) btn.classList.add('hand-active');
            else btn.classList.remove('hand-active');
            
            // Send to Host
            hostConnection.send({ type: 'HAND', value: myHandRaised });
        }

        function updateHandOverlay() {
            if (!isLeader) return;
            const count = connections.filter(c => c.handRaised).length;
            const overlay = document.getElementById('hand-overlay');
            const counter = document.getElementById('hand-count');
            
            counter.innerText = count;
            if (count > 0) overlay.classList.remove('hidden');
            else overlay.classList.add('hidden');
        }

        // --- DRAWING ---
        function initDrawingListeners() {
            drawCanvas.addEventListener('mousedown', startDrawing);
            drawCanvas.addEventListener('mousemove', draw);
            drawCanvas.addEventListener('mouseup', stopDrawing);
            drawCanvas.addEventListener('mouseout', stopDrawing);
            drawCanvas.addEventListener('touchstart', (e) => {
                if(e.touches.length === 1) { e.preventDefault(); startDrawing(e.touches[0]); }
            });
            drawCanvas.addEventListener('touchmove', (e) => {
                if(e.touches.length === 1) { e.preventDefault(); draw(e.touches[0]); }
            });
            drawCanvas.addEventListener('touchend', stopDrawing);
        }

        function getPos(e) {
            const rect = drawCanvas.getBoundingClientRect();
            return {
                x: (e.clientX - rect.left) * (drawCanvas.width / rect.width),
                y: (e.clientY - rect.top) * (drawCanvas.height / rect.height)
            };
        }

        function startDrawing(e) {
            if (!isLeader) return;
            isDrawing = true;
            const pos = getPos(e);
            lastX = pos.x; lastY = pos.y;
            performDraw(lastX, lastY, lastX, lastY, true);
        }

        function draw(e) {
            if (!isDrawing || !isLeader) return;
            const pos = getPos(e);
            performDraw(lastX, lastY, pos.x, pos.y, true);
            lastX = pos.x; lastY = pos.y;
        }

        function stopDrawing() { isDrawing = false; }

        function performDraw(x0, y0, x1, y1, emit) {
            const w = drawCanvas.width; const h = drawCanvas.height;
            drawCtx.beginPath();
            drawCtx.moveTo(x0, y0); drawCtx.lineTo(x1, y1); drawCtx.stroke();
            if (emit && isLeader) {
                const normCoords = [x0 / w, y0 / h, x1 / w, y1 / h];
                if (!pageMarks[pageNum]) pageMarks[pageNum] = [];
                pageMarks[pageNum].push(normCoords);
                broadcast({ type: 'DRAW', coords: normCoords });
            }
        }

        function receiveDraw(nx0, ny0, nx1, ny1) {
            const w = drawCanvas.width; const h = drawCanvas.height;
            if (!pageMarks[pageNum]) pageMarks[pageNum] = [];
            pageMarks[pageNum].push([nx0, ny0, nx1, ny1]);
            drawCtx.beginPath();
            drawCtx.moveTo(nx0 * w, ny0 * h); drawCtx.lineTo(nx1 * w, ny1 * h); drawCtx.stroke();
        }

        function redrawStoredLines(pNum) {
            if (!pageMarks[pNum]) return;
            const w = drawCanvas.width; const h = drawCanvas.height;
            drawCtx.lineCap = 'round'; drawCtx.lineJoin = 'round';
            drawCtx.lineWidth = 4; drawCtx.strokeStyle = '#b80000';
            drawCtx.beginPath();
            pageMarks[pNum].forEach(line => {
                drawCtx.moveTo(line[0] * w, line[1] * h);
                drawCtx.lineTo(line[2] * w, line[3] * h);
            });
            drawCtx.stroke();
        }

        function clearDrawings(emit) {
            drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            if (emit) {
                pageMarks[pageNum] = [];
                if (isLeader) broadcast({ type: 'CLEAR' });
            }
        }

        // --- CONTROLS ---
        function onPrevPage() {
            if (!pdfDoc || pageNum <= 1) return;
            pageNum--;
            clearDrawings(false);
            queueRenderPage(pageNum);
            if (isLeader) broadcast({ type: 'PAGE', value: pageNum });
        }

        function onNextPage() {
            if (!pdfDoc || pageNum >= pdfDoc.numPages) return;
            pageNum++;
            clearDrawings(false);
            queueRenderPage(pageNum);
            if (isLeader) broadcast({ type: 'PAGE', value: pageNum });
        }

        function onRotate() {
            rotation += 90;
            if (rotation >= 360) rotation = 0;
            clearDrawings(false); queueRenderPage(pageNum);
        }

        function toggleQR() {
            const modal = document.getElementById('qr-modal');
            modal.style.display = (modal.style.display === 'flex') ? 'none' : 'flex';
        }

        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if(pdfDoc) { clearDrawings(false); renderPage(pageNum); }
            }, 200);
        });

        // --- PEER JS LOGIC ---

        function initLeader() {
            isLeader = true;
            updateToolbarForRole();
            document.getElementById('speaker-menu').classList.remove('hidden');
            drawCanvas.style.pointerEvents = 'auto';

            peer = new Peer();
            peer.on('open', id => {
                const url = window.location.href.split('?')[0] + '?host=' + id;
                document.getElementById('share-link').value = url;
                
                document.getElementById("qr-container").innerHTML = "";
                document.getElementById("qrcode-modal-tgt").innerHTML = "";
                
                // Black QR Codes
                new QRCode(document.getElementById("qr-container"), { text: url, width: 150, height: 150, colorDark: "#000000" });
                new QRCode(document.getElementById("qrcode-modal-tgt"), { text: url, width: 250, height: 250, colorDark: "#000000" });
                
                document.getElementById('btn-start-sync').disabled = false;
            });

            peer.on('connection', conn => {
                const client = { id: conn.peer, conn: conn, ready: false, handRaised: false };
                connections.push(client);
                updateClientList();

                if (transferInProgress) {
                    conn.on('open', () => syncSingleClient(client));
                }

                conn.on('data', data => {
                    if (data.type === 'ACK_READY') {
                        client.ready = true;
                        updateClientList();
                        checkGlobalSync();
                    }
                    if (data.type === 'HAND') {
                        client.handRaised = data.value;
                        updateHandOverlay();
                    }
                });

                conn.on('close', () => {
                    connections = connections.filter(c => c.conn !== conn);
                    updateClientList();
                    updateHandOverlay();
                });
            });
        }

        function updateClientList() {
            // Update Toolbar Count
            document.getElementById('user-count-val').innerText = connections.length;
            
            // Update Menu List
            const list = document.getElementById('client-list');
            if(connections.length === 0) {
                list.innerHTML = '<div style="padding:15px; text-align:center; color:#888;">Чекаємо глядачів...</div>';
                return;
            }
            list.innerHTML = connections.map(c => `
                <div class="client-row">
                    <span>Глядач ${c.id.substr(0,4)}</span>
                    <span class="${c.ready ? 'status-ready' : 'status-wait'}">
                        ${c.ready ? 'Готовий' : 'Синхро'}
                    </span>
                </div>
            `).join('');
            
            if(!transferInProgress) {
                document.getElementById('btn-start-sync').innerHTML = `<i data-lucide="play"></i> ПОЧАТИ (${connections.length})`;
                lucide.createIcons();
            }
        }

        function startDistribution() {
            if(leaderPdfBlob) renderPdf(URL.createObjectURL(leaderPdfBlob));
            else renderPdf(DEFAULT_PDF_URL);

            if (connections.length === 0) {
                 document.getElementById('ui-layer').classList.add('hidden');
                 return;
            }
            
            transferInProgress = true;
            document.getElementById('btn-start-sync').style.display = 'none';
            document.getElementById('sync-status').style.display = 'block';
            connections.forEach(c => syncSingleClient(c));
        }

        function syncSingleClient(client) {
            client.ready = false;
            updateClientList();
            
            const mode = leaderPdfBlob ? 'custom' : 'default';
            client.conn.send({ type: 'INIT', mode: mode });

            if (mode === 'custom') sendFileRaw(client.conn, leaderPdfBlob);
        }

        function sendFileRaw(conn, blob) {
            conn.send({ type: 'FILE_HEADER', size: blob.size });
            let offset = 0;
            const reader = new FileReader();
            reader.onload = function(e) {
                if (conn.dataChannel.bufferedAmount > 16 * 1024 * 1024) {
                    setTimeout(() => { conn.send(e.target.result); nextSlice(); }, 100);
                    return;
                }
                try { conn.send(e.target.result); } catch(err) {}
                offset += e.target.result.byteLength;
                nextSlice();
            };
            function nextSlice() {
                if (offset < blob.size) {
                    if (conn.dataChannel.bufferedAmount > 64 * 1024) setTimeout(nextSlice, 10);
                    else reader.readAsArrayBuffer(blob.slice(offset, offset + CHUNK_SIZE));
                } else conn.send({ type: 'FILE_END' });
            }
            nextSlice();
        }

        function checkGlobalSync() {
            if (transferInProgress && connections.length > 0 && connections.every(c => c.ready)) {
                document.getElementById('ui-layer').classList.add('hidden');
                broadcast({ type: 'PAGE', value: pageNum });
            }
        }

        function broadcast(msg) {
            connections.forEach(c => { if(c.conn.open) c.conn.send(msg); });
        }

        function joinGame(id) {
            const hostId = id || document.getElementById('join-input').value;
            if (!hostId) return alert("Потрібен ID або QR");

            document.getElementById('listener-menu').classList.add('hidden');
            document.getElementById('loading-menu').classList.remove('hidden');
            isLeader = false;
            updateToolbarForRole();

            if(html5QrcodeScanner) try { html5QrcodeScanner.clear(); } catch(e){}

            peer = new Peer();
            peer.on('open', () => {
                const conn = peer.connect(hostId, { reliable: true });
                hostConnection = conn;

                conn.on('open', () => document.getElementById('loading-msg').innerText = "Пошук ведучого...");

                conn.on('data', async data => {
                    if (data instanceof ArrayBuffer || data instanceof Uint8Array) {
                        incomingChunks.push(data);
                        incomingSize += data.byteLength || data.length;
                        const pct = Math.floor((incomingSize / totalExpectedSize) * 100);
                        document.getElementById('progress-bar-fill').style.width = pct + '%';
                        document.getElementById('status-text').innerText = `${pct}%`;
                        return;
                    }
                    if (data.type === 'INIT') {
                        if (data.mode === 'default') {
                            document.getElementById('loading-msg').innerText = "Завантаження...";
                            const ok = await renderPdf(DEFAULT_PDF_URL);
                            if(ok) finishSetup();
                        } else {
                            document.getElementById('loading-msg').innerText = "Прийом файлу...";
                            document.getElementById('progress-bar-container').style.display = 'block';
                            incomingChunks = []; incomingSize = 0;
                        }
                    }
                    if (data.type === 'FILE_HEADER') totalExpectedSize = data.size;
                    if (data.type === 'FILE_END') {
                        document.getElementById('loading-msg').innerText = "Обробка...";
                        const blob = new Blob(incomingChunks, { type: 'application/pdf' });
                        const ok = await renderPdf(URL.createObjectURL(blob));
                        if (ok) finishSetup();
                    }
                    if (data.type === 'PAGE') {
                        pageNum = data.value;
                        clearDrawings(false); if(pdfDoc) queueRenderPage(pageNum);
                    }
                    if (data.type === 'DRAW') receiveDraw(data.coords[0], data.coords[1], data.coords[2], data.coords[3]);
                    if (data.type === 'CLEAR') clearDrawings(true);
                });

                function finishSetup() {
                    conn.send({ type: 'ACK_READY' });
                    document.getElementById('ui-layer').classList.add('hidden');
                    const currentUrl = window.location.href.split('?')[0] + '?host=' + hostId;
                    document.getElementById("qrcode-modal-tgt").innerHTML = "";
                    new QRCode(document.getElementById("qrcode-modal-tgt"), { text: currentUrl, width: 250, height: 250, colorDark: "#000000" });
                }
                conn.on('close', () => alert("Ведучий від'єднався"));
            });
        }
    </script>
</body>
</html>
